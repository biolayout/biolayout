/*

 BioLayoutExpress3D - A tool for visualisation
 and analysis of biological networks

 Copyright (c) 2006-2012 Genome Research Ltd.
 Authors: Thanos Theo, Anton Enright, Leon Goldovsky, Ildefonso Cases, Markus Brosch, Stijn van Dongen, Michael Kargas, Benjamin Boyer and Tom Freeman
 Contact: support@biolayout.org

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

 @ author, GLSL & OpenGL code author Thanos Theo, 2012

*/

#extension GL_ARB_tessellation_shader : enable

// Phong tess patch data
struct PhongPatch
{
    float termIJ;
    float termJK;
    float termIK;
};

patch in vec3 tsNormal[3];
patch in vec4 tsSceneColor[3];
patch in vec2 tsTexCoord[3];

out vec3 TS_GS_POSITION;
out vec3 TS_GS_NORMAL;
out vec4 TS_GS_SCENE_COLOR;
out vec2 TS_GS_TEX_COORDS;
#if APPLY_NORMALS_GEOMETRY_CONDITION
    out vec4 TS_GS_VERTEX_NORMAL_POSITION;
#endif

uniform bool phongTessellationLodTexturing;
uniform bool phongTessellationLodSphericalMapping;
uniform float phongTessellationLodMorphing;
// uniform bool phongTessellationUserClipping;
uniform float phongTessellationLodTimer;
uniform float phongTessellationLodTessAlpha = 0.5;

vec3 interpolate3D(in vec3, in vec3, in vec3, in float, in float, in float);
float PIi(in int, in vec3, in int);
vec3 applyMorphing(in vec3, in float, in float);
vec2 applySphericalCoordinates(in vec3, in vec3);
vec2 createTextureCoord2D(in vec2, in vec2, in vec2, in float, in float, in float);

layout (triangles, fractional_odd_spacing, ccw) in;

#define Pi  gl_in[0].gl_Position.xyz
#define Pj  gl_in[1].gl_Position.xyz
#define Pk  gl_in[2].gl_Position.xyz
#define tc1 gl_TessCoord

void main()
{    
    // precompute squared tesscoords
    vec3 tc2 = tc1 * tc1;

    // compute interpolated normal
    vec3 normal = interpolate3D(tsNormal[0], tsNormal[1], tsNormal[2], tc1.x, tc1.y, tc1.z);

    // interpolated position
    vec3 baryCenterPosition = interpolate3D(Pi, Pj, Pk, tc1.x, tc1.y, tc1.z);

    // compute patch data                   
    PhongPatch tsPhongPatch[3];
    for (int i = 0; i < 3; i++)
    {
        tsPhongPatch[i].termIJ = PIi(0, Pj, i) + PIi(1, Pi, i);
        tsPhongPatch[i].termJK = PIi(1, Pk, i) + PIi(2, Pj, i);
        tsPhongPatch[i].termIK = PIi(2, Pi, i) + PIi(0, Pk, i);
    }

    // build terms
    vec3 termIJ = vec3(tsPhongPatch[0].termIJ, tsPhongPatch[1].termIJ, tsPhongPatch[2].termIJ);
    vec3 termJK = vec3(tsPhongPatch[0].termJK, tsPhongPatch[1].termJK, tsPhongPatch[2].termJK);
    vec3 termIK = vec3(tsPhongPatch[0].termIK, tsPhongPatch[1].termIK, tsPhongPatch[2].termIK);

    // phong tesselated position
    vec3 phongPosition = tc2[0] * Pi + tc2[1] * Pj + tc2[2] * Pk + tc1[0] * tc1[1] * termIJ + tc1[1] * tc1[2] * termJK + tc1[2] * tc1[0] * termIK;

    // final position
    vec3 xyz = mix(baryCenterPosition, phongPosition, phongTessellationLodTessAlpha);

    TS_GS_NORMAL = gl_NormalMatrix * normal;
    TS_GS_SCENE_COLOR = (tsSceneColor[0] + tsSceneColor[1] + tsSceneColor[2]) / 3.0;
    
    if (phongTessellationLodMorphing != 0.0)    
        xyz = applyMorphing(xyz, phongTessellationLodMorphing, phongTessellationLodTimer);

    #if APPLY_NORMALS_GEOMETRY_CONDITION
        float intensity = length( normalize(TS_GS_NORMAL) ) / 10.0;
        TS_GS_VERTEX_NORMAL_POSITION = vec4( (1.0 + intensity) * xyz, 1.0 );
    #endif

    #if GPU_GEOMETRY_SHADER4_COMPATIBILITY_CONDITION    
        gl_Position = vec4(xyz, 1.0);
    #else    
        gl_Position = gl_ModelViewProjectionMatrix * vec4(xyz, 1.0);
    #endif

    // if (pointSpheresLodUserClipping) // disabled due to GL error generation
    // {
        // used with the glClipPlane() command for user defined clipping planes mimicking OpenGL's fixed functionality
        // gl_ClipVertex = gl_ModelViewMatrix * vec4(xyz, 1.0);
    // }

    TS_GS_POSITION = vec3( gl_ModelViewMatrix * vec4(xyz, 1.0) );
    if (phongTessellationLodTexturing)
        TS_GS_TEX_COORDS = (phongTessellationLodSphericalMapping) ? applySphericalCoordinates(TS_GS_POSITION, TS_GS_NORMAL) : createTextureCoord2D(tsTexCoord[0], tsTexCoord[1], tsTexCoord[2], tc1.x, tc1.y, tc1.z);
}

float PIi(in int i, in vec3 q, in int j)
{
    vec3 q_minus_p = q - gl_in[i].gl_Position.xyz;
    return q[j] - dot(q_minus_p, tsNormal[i]) * tsNormal[i][j];
}