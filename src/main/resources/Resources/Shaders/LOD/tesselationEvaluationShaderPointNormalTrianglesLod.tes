/*

 BioLayoutExpress3D - A tool for visualisation
 and analysis of biological networks

 Copyright (c) 2006-2012 Genome Research Ltd.
 Authors: Thanos Theo, Anton Enright, Leon Goldovsky, Ildefonso Cases, Markus Brosch, Stijn van Dongen, Michael Kargas, Benjamin Boyer and Tom Freeman
 Contact: support@biolayout.org

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

 @ author, GLSL & OpenGL code author Thanos Theo, 2012

*/

#extension GL_ARB_tessellation_shader : enable

patch in vec3 tsNormal[3];
patch in vec4 tsSceneColor[3];
patch in vec2 tsTexCoord[3];

out vec3 TS_GS_POSITION;
out vec3 TS_GS_NORMAL;
out vec4 TS_GS_SCENE_COLOR;
out vec2 TS_GS_TEX_COORDS;
#if APPLY_NORMALS_GEOMETRY_CONDITION
    out vec4 TS_GS_VERTEX_NORMAL_POSITION;
#endif

uniform bool pointNormalTrianglesLodTexturing;
uniform bool pointNormalTrianglesLodSphericalMapping;
uniform float pointNormalTrianglesLodMorphing;
// uniform bool pointNormalTrianglesUserClipping;
uniform float pointNormalTrianglesLodTimer;
uniform float pointNormalTrianglesLodTessAlpha = 0.5;

vec3 interpolate3D(in vec3, in vec3, in vec3, in float, in float, in float);
vec3 applyMorphing(in vec3, in float, in float);
vec2 applySphericalCoordinates(in vec3, in vec3);
vec2 createTextureCoord2D(in vec2, in vec2, in vec2, in float, in float, in float);

layout (triangles, equal_spacing, ccw) in;

#define p1 gl_in[0].gl_Position.xyz
#define p2 gl_in[1].gl_Position.xyz
#define p3 gl_in[2].gl_Position.xyz
#define n1 tsNormal[0]
#define n2 tsNormal[1]
#define n3 tsNormal[2]
#define u gl_TessCoord.x
#define v gl_TessCoord.y
#define w gl_TessCoord.z

void main()
{    
    vec3 b300 = p1;
    vec3 b030 = p2;
    vec3 b003 = p3;

    float w12 = dot(p2 - p1, n1);
    float w21 = dot(p1 - p2, n2);
    float w13 = dot(p3 - p1, n1);
    float w31 = dot(p1 - p3, n3);
    float w23 = dot(p3 - p2, n2);
    float w32 = dot(p2 - p3, n3);

    vec3 b210 = (2.0 * p1 + p2 - w12 * n1) / 3.0;
    vec3 b120 = (2.0 * p2 + p1 - w21 * n2) / 3.0;
    vec3 b021 = (2.0 * p2 + p3 - w23 * n2) / 3.0;
    vec3 b012 = (2.0 * p3 + p2 - w32 * n3) / 3.0;
    vec3 b102 = (2.0 * p3 + p1 - w31 * n3) / 3.0;
    vec3 b201 = (2.0 * p1 + p3 - w13 * n1) / 3.0;
        
    vec3 ee = (b210 + b120 + b021 + b012 + b102 + b201) / 6.0;
    vec3 vv = (p1 + p2 + p3) / 3.0;
    vec3 b111 = ee + (ee - vv) / 2.0;

    vec3 PNTrianglesPosition = 1.0 * b300 * w * w * w + 1.0 * b030 * u * u * u + 1.0 * b003 * v * v * v +
                               3.0 * b210 * u * w * w + 3.0 * b120 * u * u * w + 3.0 * b201 * v * w * w +
                               3.0 * b021 * u * u * v + 3.0 * b102 * v * v * w + 3.0 * b012 * u * v * v +   
                               6.0 * b111 * u * v * w;

    // interpolated position
    vec3 baryCenterPosition = interpolate3D(p1, p2, p3, w, u, v); // has to be inverted to work ok here!

    // final position
    vec3 xyz = mix(baryCenterPosition, PNTrianglesPosition, pointNormalTrianglesLodTessAlpha);

    float v12 = 2.0 * dot(p2 - p1, n1 + n2) / dot(p2 - p1, p2 - p1);
    float v23 = 2.0 * dot(p3 - p2, n2 + n3) / dot(p3 - p2, p3 - p2);
    float v31 = 2.0 * dot(p1 - p3, n3 + n1) / dot(p1 - p3, p1 - p3);

    vec3 n200 = n1;
    vec3 n020 = n2;
    vec3 n002 = n3;
    vec3 n110 = normalize( n1 + n2 - v12 * (p2 - p1) );
    vec3 n011 = normalize( n2 + n3 - v23 * (p3 - p2) );
    vec3 n101 = normalize( n3 + n1 - v31 * (p1 - p3) );
        
    // compute normal
    vec3 PNTrianglesNormal = n200 * w * w + n020 * u * u + n002 * v * v + n110 * w * u + n011 * u * v + n101 * w * v;

    // interpolated normal
    vec3 baryCenterNormal = interpolate3D(tsNormal[0], tsNormal[1], tsNormal[2], w, u, v); // has to be inverted to work ok here!

    // final normal
    vec3 normal = mix(baryCenterNormal, PNTrianglesNormal, pointNormalTrianglesLodTessAlpha);

    TS_GS_NORMAL = gl_NormalMatrix * normal;
    TS_GS_SCENE_COLOR = (tsSceneColor[0] + tsSceneColor[1] + tsSceneColor[2]) / 3.0;
    
    if (pointNormalTrianglesLodMorphing != 0.0)    
        xyz = applyMorphing(xyz, pointNormalTrianglesLodMorphing, pointNormalTrianglesLodTimer);

    #if APPLY_NORMALS_GEOMETRY_CONDITION
        float intensity = length( normalize(TS_GS_NORMAL) ) / 10.0;
        TS_GS_VERTEX_NORMAL_POSITION = vec4( (1.0 + intensity) * xyz, 1.0 );
    #endif

    #if GPU_GEOMETRY_SHADER4_COMPATIBILITY_CONDITION    
        gl_Position = vec4(xyz, 1.0);
    #else    
        gl_Position = gl_ModelViewProjectionMatrix * vec4(xyz, 1.0);
    #endif

    // if (pointSpheresLodUserClipping) // disabled due to GL error generation
    // {
        // used with the glClipPlane() command for user defined clipping planes mimicking OpenGL's fixed functionality
        // gl_ClipVertex = gl_ModelViewMatrix * vec4(xyz, 1.0);
    // }

    TS_GS_POSITION = vec3( gl_ModelViewMatrix * vec4(xyz, 1.0) );
    if (pointNormalTrianglesLodTexturing)
        TS_GS_TEX_COORDS = (pointNormalTrianglesLodSphericalMapping) ? applySphericalCoordinates(TS_GS_POSITION, TS_GS_NORMAL) : createTextureCoord2D(tsTexCoord[0], tsTexCoord[1], tsTexCoord[2], w, u, v); // has to be inverted to work ok here!
}